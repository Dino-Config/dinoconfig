/**
 * @fileoverview TypeScript type generator from DinoConfig introspection data.
 * @module @dinoconfig/cli/type-generator
 */

import type {
  IntrospectionResult,
  BrandInfoDetail,
  ConfigInfoDetail,
  KeyInfo,
} from '@dinoconfig/dinoconfig-js-sdk';
import { CLI_NAME, CLI_VERSION, DEFAULT_NAMESPACE } from './constants';

/**
 * TypeScript reserved words that need special handling.
 */
const RESERVED_WORDS = new Set([
  'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger',
  'default', 'delete', 'do', 'else', 'enum', 'export', 'extends',
  'false', 'finally', 'for', 'function', 'if', 'import', 'in',
  'instanceof', 'new', 'null', 'return', 'super', 'switch', 'this',
  'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with',
]);

/**
 * Primitive types that can be inferred from array values.
 */
type PrimitiveType = 'string' | 'number' | 'boolean';

/**
 * Checks if a type string is a primitive type.
 */
function isPrimitiveType(type: string): type is PrimitiveType {
  return type === 'string' || type === 'number' || type === 'boolean';
}

/**
 * Generates TypeScript type definitions from DinoConfig introspection data.
 *
 * @example
 * ```typescript
 * const generator = new TypeGenerator('DinoConfig');
 * const content = generator.generate(introspectionData);
 * ```
 */
export class TypeGenerator {
  constructor(private readonly namespace: string = DEFAULT_NAMESPACE) {}

  /**
   * Generates the complete TypeScript declaration file content.
   */
  generate(data: IntrospectionResult): string {
    const lines: string[] = [
      ...this.generateHeader(data),
      '',
      `export namespace ${this.namespace} {`,
    ];

    for (const brand of data.brands) {
      lines.push(this.generateBrandNamespace(brand));
      lines.push('');
    }

    // Remove trailing empty line before closing brace
    this.removeTrailingEmpty(lines);
    lines.push('}', '', ...this.generateHelperType(), '');

    return lines.join('\n');
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Private: Header & Helper Generation
  // ─────────────────────────────────────────────────────────────────────────────

  private generateHeader(data: IntrospectionResult): string[] {
    return [
      '/**',
      ' * DinoConfig Generated Types',
      ' *',
      ` * Auto-generated by ${CLI_NAME} v${CLI_VERSION}`,
      ` * Generated at: ${new Date().toISOString()}`,
      ` * Company: ${data.company}`,
      ' *',
      ' * DO NOT EDIT THIS FILE MANUALLY',
      ' * Run the codegen command to regenerate:',
      ` *   npx ${CLI_NAME} codegen --api-key=<your-key> --output=<this-file>`,
      ' */',
    ];
  }

  private generateHelperType(): string[] {
    return [
      '/**',
      ' * Helper type to extract config type from namespace path',
      ' * @example',
      ` * type Flags = ${this.namespace}.ConfigType<'MyBrand', 'FeatureFlags'>;`,
      ' */',
      'export type ConfigType<',
      `  Brand extends keyof typeof ${this.namespace},`,
      `  Config extends keyof (typeof ${this.namespace})[Brand]`,
      `> = (typeof ${this.namespace})[Brand][Config];`,
    ];
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Private: Namespace & Interface Generation
  // ─────────────────────────────────────────────────────────────────────────────

  private generateBrandNamespace(brand: BrandInfoDetail): string {
    const namespaceName = this.sanitizeIdentifier(brand.name);
    const lines: string[] = [
      '  /**',
      `   * ${brand.name} brand configurations`,
      '   * @namespace',
      '   */',
      `  export namespace ${namespaceName} {`,
    ];

    for (const config of brand.configs) {
      lines.push(this.generateConfigInterface(config), '');
    }

    this.removeTrailingEmpty(lines);
    lines.push('  }');

    return lines.join('\n');
  }

  private generateConfigInterface(config: ConfigInfoDetail): string {
    const interfaceName = this.sanitizeIdentifier(config.name);
    const lines: string[] = [
      '    /**',
      `     * ${config.name} configuration`,
    ];

    if (config.keys.length > 0) {
      lines.push(`     * @property {${config.keys.length}} keys`);
    }

    lines.push('     */', `    export interface ${interfaceName} {`);

    for (const key of config.keys) {
      lines.push(...this.generateProperty(key));
    }

    lines.push('    }');
    return lines.join('\n');
  }

  private generateProperty(key: KeyInfo): string[] {
    const propName = this.sanitizeIdentifier(key.name);
    const tsType = this.toTypeScriptType(key.type, key.value);
    return [`      /** ${key.type} */`, `      ${propName}: ${tsType};`];
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Private: Type Conversion & Utilities
  // ─────────────────────────────────────────────────────────────────────────────

  private toTypeScriptType(type: string, value?: unknown): string {
    switch (type) {
      case 'boolean':
      case 'number':
      case 'string':
        return type;
      case 'array':
        return this.inferArrayType(value);
      case 'object':
        return 'Record<string, unknown>';
      default:
        return 'unknown';
    }
  }

  private inferArrayType(value?: unknown): string {
    if (Array.isArray(value) && value.length > 0) {
      const elementType = typeof value[0];
      if (isPrimitiveType(elementType)) {
        return `${elementType}[]`;
      }
    }
    return 'unknown[]';
  }

  private sanitizeIdentifier(name: string): string {
    let sanitized = name.replace(/[^a-zA-Z0-9_$]/g, '_');

    if (/^[0-9]/.test(sanitized)) {
      sanitized = '_' + sanitized;
    }

    if (RESERVED_WORDS.has(sanitized.toLowerCase())) {
      sanitized += '_';
    }

    return sanitized;
  }

  private removeTrailingEmpty(lines: string[]): void {
    while (lines.length > 0 && lines[lines.length - 1] === '') {
      lines.pop();
    }
  }
}
