/**
 * @fileoverview Java model generator from DinoConfig introspection data.
 * @module @dinoconfig/cli/java-model-generator
 */

import type {
  IntrospectionResult,
  BrandInfoDetail,
  ConfigInfoDetail,
  KeyInfo,
} from '@dinoconfig/dinoconfig-js-sdk';
import { CLI_NAME, CLI_VERSION } from './constants';

/**
 * Java reserved words that need special handling.
 */
const JAVA_RESERVED_WORDS = new Set([
  'abstract', 'assert', 'boolean', 'break', 'byte', 'case', 'catch', 'char',
  'class', 'const', 'continue', 'default', 'do', 'double', 'else', 'enum',
  'extends', 'final', 'finally', 'float', 'for', 'goto', 'if', 'implements',
  'import', 'instanceof', 'int', 'interface', 'long', 'native', 'new', 'null',
  'package', 'private', 'protected', 'public', 'return', 'short', 'static',
  'strictfp', 'super', 'switch', 'synchronized', 'this', 'throw', 'throws',
  'transient', 'try', 'void', 'volatile', 'while',
]);

/**
 * Primitive types that can be inferred from array values.
 */
type PrimitiveType = 'string' | 'number' | 'boolean';

/**
 * Checks if a type string is a primitive type.
 */
function isPrimitiveType(type: string): type is PrimitiveType {
  return type === 'string' || type === 'number' || type === 'boolean';
}

/**
 * Generates Java model classes from DinoConfig introspection data.
 *
 * @example
 * ```typescript
 * const generator = new JavaModelGenerator();
 * const content = generator.generate(introspectionData);
 * ```
 */
export class JavaModelGenerator {
  private readonly basePackage = 'com.dinoconfig.sdk.generated';
  private readonly generatedByComment = `Generated by ${CLI_NAME} v${CLI_VERSION}`;

  /**
   * Generates Java source files for each brand and config.
   * Returns a map of file paths to file contents.
   */
  generate(data: IntrospectionResult): Map<string, string> {
    const files = new Map<string, string>();

    for (const brand of data.brands) {
      const brandPackage = this.sanitizePackageName(brand.name);
      const packageName = `${this.basePackage}.${brandPackage}`;

      for (const config of brand.configs) {
        const className = this.sanitizeClassName(config.name);
        const filePath = this.getFilePath(packageName, className);
        const content = this.generateConfigClass(packageName, className, config, brand.name);
        files.set(filePath, content);
      }
    }

    return files;
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Private: Class Generation
  // ─────────────────────────────────────────────────────────────────────────────

  private generateConfigClass(
    packageName: string,
    className: string,
    config: ConfigInfoDetail,
    brandName: string
  ): string {
    const lines: string[] = [
      this.generateHeader(config, brandName),
      '',
      `package ${packageName};`,
      '',
      'import com.fasterxml.jackson.annotation.JsonProperty;',
      '',
      'import java.util.Objects;',
    ];

    // Add imports for types used in the class
    const typesUsed = this.collectTypesUsed(config.keys);
    if (typesUsed.has('List') || typesUsed.has('Map')) {
      if (typesUsed.has('List')) {
        lines.push('import java.util.List;');
      }
      if (typesUsed.has('Map')) {
        lines.push('import java.util.Map;');
      }
      lines.push('import java.util.Collections;');
    }

    lines.push('', this.generateClassDeclaration(className, config));

    // Fields
    for (const key of config.keys) {
      lines.push(this.generateField(key));
    }

    // Default constructor
    lines.push('', this.generateDefaultConstructor(className, config.keys));

    // Full constructor
    lines.push('', this.generateFullConstructor(className, config.keys));

    // Getters
    for (const key of config.keys) {
      lines.push('', this.generateGetter(key));
    }

    // equals, hashCode, toString
    lines.push('', this.generateEqualsMethod(className, config.keys));
    lines.push('', this.generateHashCodeMethod(config.keys));
    lines.push('', this.generateToStringMethod(className, config.keys));
    lines.push('}');

    return lines.join('\n');
  }

  private generateHeader(config: ConfigInfoDetail, brandName: string): string {
    const date = new Date().toISOString();
    return `/*
 * DinoConfig Java SDK - Generated Model
 * ${this.generatedByComment}
 * Generated at: ${date}
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated from DinoConfig schema.
 * 
 * Brand: ${brandName}
 * Config: ${config.name}
 * Version: ${config.version}
 */`;
  }

  private generateClassDeclaration(className: string, config: ConfigInfoDetail): string {
    const lines: string[] = [
      '/**',
      ` * Generated model for ${config.name} configuration.`,
    ];

    if (config.description) {
      lines.push(' *', ` * ${config.description.replace(/\n/g, ' ')}`);
    }

    lines.push(' *', ' * <p>This class represents the typed structure of the configuration.', ' * All fields are immutable.', ' */');
    lines.push(`public final class ${className} {`);

    return lines.join('\n');
  }

  private generateField(key: KeyInfo): string {
    const fieldName = this.sanitizeFieldName(key.name);
    const javaType = this.toJavaType(key.type, key.value);
    const lines: string[] = [
      '    /**',
      `     * ${key.type} - ${key.name}`,
      '     */',
      `    @JsonProperty("${key.name}")`,
      `    private final ${javaType} ${fieldName};`,
    ];
    return lines.join('\n');
  }

  private generateDefaultConstructor(className: string, keys: readonly KeyInfo[]): string {
    const lines: string[] = [
      '    /**',
      '     * Default constructor for Jackson deserialization.',
      '     */',
      `    public ${className}() {`,
    ];

    for (const key of keys) {
      const fieldName = this.sanitizeFieldName(key.name);
      const javaType = this.toJavaType(key.type, key.value);
      const defaultValue = this.getDefaultValue(javaType);
      lines.push(`        this.${fieldName} = ${defaultValue};`);
    }

    lines.push('    }');
    return lines.join('\n');
  }

  private generateFullConstructor(className: string, keys: readonly KeyInfo[]): string {
    const params: string[] = [];

    for (const key of keys) {
      const fieldName = this.sanitizeFieldName(key.name);
      const javaType = this.toJavaType(key.type, key.value);
      params.push(`${javaType} ${fieldName}`);
    }

    const lines: string[] = [
      '    /**',
      `     * Creates a new ${className} instance.`,
      '     *',
    ];

    for (const key of keys) {
      const fieldName = this.sanitizeFieldName(key.name);
      lines.push(`     * @param ${fieldName} ${key.name} (${key.type})`);
    }

    lines.push('     */', `    public ${className}(${params.join(', ')}) {`);

    for (const key of keys) {
      const fieldName = this.sanitizeFieldName(key.name);
      const javaType = this.toJavaType(key.type, key.value);
      
      if (javaType.startsWith('List<')) {
        lines.push(`        this.${fieldName} = ${fieldName} != null ? Collections.unmodifiableList(${fieldName}) : Collections.emptyList();`);
      } else if (javaType.startsWith('Map<')) {
        lines.push(`        this.${fieldName} = ${fieldName} != null ? Collections.unmodifiableMap(${fieldName}) : Collections.emptyMap();`);
      } else {
        lines.push(`        this.${fieldName} = ${fieldName};`);
      }
    }

    lines.push('    }');
    return lines.join('\n');
  }

  private generateGetter(key: KeyInfo): string {
    const fieldName = this.sanitizeFieldName(key.name);
    const methodName = this.toGetterName(fieldName);
    const javaType = this.toJavaType(key.type, key.value);

    const lines: string[] = [
      '    /**',
      `     * Returns ${key.name}.`,
      '     *',
      `     * @return ${key.name} (${key.type})`,
      '     */',
      `    public ${javaType} ${methodName}() {`,
      `        return ${fieldName};`,
      '    }',
    ];

    return lines.join('\n');
  }

  private generateEqualsMethod(className: string, keys: readonly KeyInfo[]): string {
    const lines: string[] = [
      '    @Override',
      '    public boolean equals(Object o) {',
      '        if (this == o) return true;',
      '        if (o == null || getClass() != o.getClass()) return false;',
      `        ${className} that = (${className}) o;`,
      '        return ',
    ];

    const comparisons: string[] = [];
    for (const key of keys) {
      const fieldName = this.sanitizeFieldName(key.name);
      comparisons.push(`Objects.equals(${fieldName}, that.${fieldName})`);
    }

    lines.push('                ' + comparisons.join('\n                && '));
    lines.push('        ;');
    lines.push('    }');

    return lines.join('\n');
  }

  private generateHashCodeMethod(keys: readonly KeyInfo[]): string {
    const fieldNames = keys.map(k => this.sanitizeFieldName(k.name)).join(', ');
    const lines: string[] = [
      '    @Override',
      '    public int hashCode() {',
      `        return Objects.hash(${fieldNames});`,
      '    }',
    ];
    return lines.join('\n');
  }

  private generateToStringMethod(className: string, keys: readonly KeyInfo[]): string {
    if (keys.length === 0) {
      return `    @Override
    public String toString() {
        return "${className}{}";
    }`;
    }

    const lines: string[] = [
      '    @Override',
      '    public String toString() {',
      `        return "${className}{" +`,
    ];

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const fieldName = this.sanitizeFieldName(key.name);
      if (i === 0) {
        lines.push(`                "${fieldName}=" + ${fieldName}`);
      } else {
        lines.push(`                + ", ${fieldName}=" + ${fieldName}`);
      }
    }

    lines.push('                + \'}\';');
    lines.push('    }');
    return lines.join('\n');
  }

  // ─────────────────────────────────────────────────────────────────────────────
  // Private: Type Conversion & Utilities
  // ─────────────────────────────────────────────────────────────────────────────

  private toJavaType(type: string, value?: unknown): string {
    switch (type) {
      case 'boolean':
        return 'Boolean';
      case 'number':
        return 'Double'; // Use Double for numbers to handle both int and float
      case 'string':
        return 'String';
      case 'array':
        return this.inferArrayType(value);
      case 'object':
        return 'Map<String, Object>';
      default:
        return 'Object';
    }
  }

  private inferArrayType(value?: unknown): string {
    if (Array.isArray(value) && value.length > 0) {
      const elementType = typeof value[0];
      if (isPrimitiveType(elementType)) {
        switch (elementType) {
          case 'boolean':
            return 'List<Boolean>';
          case 'number':
            return 'List<Double>';
          case 'string':
            return 'List<String>';
        }
      }
    }
    return 'List<Object>';
  }

  private getDefaultValue(javaType: string): string {
    switch (javaType) {
      case 'Boolean':
        return 'null';
      case 'Double':
      case 'Integer':
      case 'Long':
        return 'null';
      case 'String':
        return 'null';
      case 'List<Boolean>':
      case 'List<Double>':
      case 'List<String>':
      case 'List<Object>':
        return 'Collections.emptyList()';
      case 'Map<String, Object>':
        return 'Collections.emptyMap()';
      default:
        return 'null';
    }
  }

  private sanitizeClassName(name: string): string {
    let sanitized = name.replace(/[^a-zA-Z0-9]/g, '');

    if (sanitized.length === 0) {
      sanitized = 'Config';
    }

    if (/^[0-9]/.test(sanitized)) {
      sanitized = 'Config' + sanitized;
    }

    // Capitalize first letter
    sanitized = sanitized.charAt(0).toUpperCase() + sanitized.slice(1);

    if (JAVA_RESERVED_WORDS.has(sanitized.toLowerCase())) {
      sanitized += 'Config';
    }

    return sanitized;
  }

  private sanitizePackageName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '')
      .replace(/^([0-9])/, '_$1');
  }

  private sanitizeFieldName(name: string): string {
    let sanitized = name.replace(/[^a-zA-Z0-9_$]/g, '_');

    if (sanitized.length === 0) {
      sanitized = 'value';
    }

    if (/^[0-9]/.test(sanitized)) {
      sanitized = '_' + sanitized;
    }

    // Convert to camelCase if it's not already
    sanitized = sanitized.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
    if (sanitized.charAt(0).toUpperCase() === sanitized.charAt(0) && /^[a-z]/.test(name)) {
      sanitized = sanitized.charAt(0).toLowerCase() + sanitized.slice(1);
    }

    if (JAVA_RESERVED_WORDS.has(sanitized.toLowerCase())) {
      sanitized += '_';
    }

    return sanitized;
  }

  private toGetterName(fieldName: string): string {
    return 'get' + fieldName.charAt(0).toUpperCase() + fieldName.slice(1);
  }

  private collectTypesUsed(keys: readonly KeyInfo[]): Set<string> {
    const types = new Set<string>();
    for (const key of keys) {
      const javaType = this.toJavaType(key.type, key.value);
      if (javaType.startsWith('List<')) {
        types.add('List');
      }
      if (javaType.startsWith('Map<')) {
        types.add('Map');
      }
    }
    return types;
  }

  private getFilePath(packageName: string, className: string): string {
    // Convert package name to directory path
    const packagePath = packageName.replace(/\./g, '/');
    return `${packagePath}/${className}.java`;
  }
}
