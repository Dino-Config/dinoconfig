---
sidebar_position: 5
title: Typed Configurations
description: Generate type-safe Java model classes for your DinoConfig configurations. Use Jackson annotations, Lombok, and Java records for type safety.
keywords: [typed configs, type safety, code generation, jackson, lombok, java records, pojo]
---

# Typed Configurations

The DinoConfig Java SDK supports fully typed configuration access through generated model classes. This provides compile-time type safety, IDE autocomplete, and eliminates runtime casting errors.

## Overview

Instead of working with generic `Map<String, Object>`:

```java
// ❌ Untyped - requires casting, no IDE support
var config = sdk.getConfigAPI().get("MyApp.Settings");
String theme = (String) config.getData().getValue("theme");
Integer maxItems = (Integer) config.getData().getValue("maxItems");
```

Use typed models:

```java
// ✅ Type-safe - full IDE support, no casting
var config = sdk.getConfigAPI().getAs("MyApp.Settings", AppSettings.class);
String theme = config.getData().getTheme();
int maxItems = config.getData().getMaxItems();
```

## Creating Model Classes

### Manual Definition

Define Java classes that match your configuration structure:

```java title="src/main/java/com/example/config/AppSettings.java"
public class AppSettings {
    private String theme;
    private int maxItems;
    private List<String> features;
    private DatabaseConfig database;
    
    // Getters and setters (required for Jackson)
    public String getTheme() { return theme; }
    public void setTheme(String theme) { this.theme = theme; }
    
    public int getMaxItems() { return maxItems; }
    public void setMaxItems(int maxItems) { this.maxItems = maxItems; }
    
    public List<String> getFeatures() { return features; }
    public void setFeatures(List<String> features) { this.features = features; }
    
    public DatabaseConfig getDatabase() { return database; }
    public void setDatabase(DatabaseConfig database) { this.database = database; }
}
```

```java title="src/main/java/com/example/config/DatabaseConfig.java"
public class DatabaseConfig {
    private String host;
    private int port;
    private String name;
    private int poolSize;
    private boolean ssl;
    
    // Getters and setters
    public String getHost() { return host; }
    public void setHost(String host) { this.host = host; }
    
    public int getPort() { return port; }
    public void setPort(int port) { this.port = port; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public int getPoolSize() { return poolSize; }
    public void setPoolSize(int poolSize) { this.poolSize = poolSize; }
    
    public boolean isSsl() { return ssl; }
    public void setSsl(boolean ssl) { this.ssl = ssl; }
}
```

### Using Lombok

Simplify with Lombok:

```java title="src/main/java/com/example/config/AppSettings.java"
import lombok.Data;

@Data
public class AppSettings {
    private String theme;
    private int maxItems;
    private List<String> features;
    private DatabaseConfig database;
}

@Data
public class DatabaseConfig {
    private String host;
    private int port;
    private String name;
    private int poolSize;
    private boolean ssl;
}
```

### Using Java Records (Java 16+)

```java title="src/main/java/com/example/config/AppSettings.java"
public record AppSettings(
    String theme,
    int maxItems,
    List<String> features,
    DatabaseConfig database
) {}

public record DatabaseConfig(
    String host,
    int port,
    String name,
    int poolSize,
    boolean ssl
) {}
```

## Generated Types with CLI

For the best experience, use the DinoConfig CLI to generate Java classes from your configuration schemas.

### Generate Classes

```bash
npx @dinoconfig/cli javagen \
  --api-key=dino_your-key \
  --output=./src/main/java/com/example/config \
  --package=com.example.config
```

This generates properly typed Java classes:

```java title="src/main/java/com/example/config/MyAppSettings.java"
// Auto-generated by @dinoconfig/cli
// Do not edit manually

package com.example.config;

import java.util.List;
import com.fasterxml.jackson.annotation.JsonProperty;

public class MyAppSettings {
    
    @JsonProperty("theme")
    private ThemeType theme;
    
    @JsonProperty("maxItems")
    private int maxItems;
    
    @JsonProperty("features")
    private List<String> features;
    
    @JsonProperty("database")
    private DatabaseConfig database;
    
    public enum ThemeType {
        @JsonProperty("light") LIGHT,
        @JsonProperty("dark") DARK,
        @JsonProperty("system") SYSTEM
    }
    
    // Getters, setters, toString, equals, hashCode...
}
```

## Using Typed Models

### Basic Usage

```java
import com.example.config.AppSettings;

var response = sdk.getConfigAPI().getAs("MyApp.Settings", AppSettings.class);

if (response.hasData()) {
    AppSettings settings = response.getData();
    
    // Full IDE autocomplete and type safety
    String theme = settings.getTheme();
    int maxItems = settings.getMaxItems();
    List<String> features = settings.getFeatures();
    
    // Nested objects are also typed
    DatabaseConfig db = settings.getDatabase();
    String connectionUrl = String.format("jdbc:postgresql://%s:%d/%s",
        db.getHost(),
        db.getPort(),
        db.getName()
    );
}
```

### Enums

Configure enum values for type-safe string fields:

```java
public class FeatureFlags {
    private boolean darkMode;
    private boolean newDashboard;
    private RolloutStage stage;
    
    public enum RolloutStage {
        @JsonProperty("alpha") ALPHA,
        @JsonProperty("beta") BETA,
        @JsonProperty("ga") GA
    }
    
    // Getters and setters
}

// Usage
var flags = sdk.getConfigAPI().getAs("MyApp.FeatureFlags", FeatureFlags.class);
if (flags.getData().getStage() == RolloutStage.GA) {
    enableFullFeatures();
}
```

### Optional Fields

Handle optional configuration values:

```java
import java.util.Optional;

public class AppSettings {
    private String theme;
    private Integer timeout;  // Use wrapper types for optional primitives
    private String customEndpoint;  // Nullable string
    
    public Optional<Integer> getTimeout() {
        return Optional.ofNullable(timeout);
    }
    
    public Optional<String> getCustomEndpoint() {
        return Optional.ofNullable(customEndpoint);
    }
}

// Usage
settings.getTimeout().ifPresent(t -> {
    configureTimeout(t);
});

String endpoint = settings.getCustomEndpoint()
    .orElse("https://api.default.com");
```

### Default Values

Handle missing fields with defaults:

```java
public class AppSettings {
    private String theme = "light";  // Default value
    private int maxItems = 50;
    private List<String> features = new ArrayList<>();
    
    // Getters and setters
}
```

Or handle at runtime:

```java
int maxItems = settings.getMaxItems() > 0 
    ? settings.getMaxItems() 
    : DEFAULT_MAX_ITEMS;
```

## Type-Safe Configuration Service

Create a service layer for clean access:

```java title="src/main/java/com/example/service/ConfigService.java"
import com.dinoconfig.sdk.DinoConfigSDK;
import com.example.config.*;

@Service
public class ConfigService {
    
    private final DinoConfigSDK sdk;
    
    public ConfigService(DinoConfigSDK sdk) {
        this.sdk = sdk;
    }
    
    public AppSettings getAppSettings() {
        var response = sdk.getConfigAPI().getAs(
            "MyApp.Settings", 
            AppSettings.class
        );
        
        if (!response.hasData()) {
            throw new ConfigurationException("Failed to load app settings");
        }
        
        return response.getData();
    }
    
    public FeatureFlags getFeatureFlags() {
        var response = sdk.getConfigAPI().getAs(
            "MyApp.FeatureFlags", 
            FeatureFlags.class
        );
        
        return response.hasData() 
            ? response.getData() 
            : FeatureFlags.defaults();
    }
    
    public DatabaseConfig getDatabaseConfig() {
        var response = sdk.getConfigAPI().getAs(
            "MyApp.Database", 
            DatabaseConfig.class
        );
        
        if (!response.hasData()) {
            throw new ConfigurationException("Failed to load database config");
        }
        
        return response.getData();
    }
}
```

Usage:

```java
@Component
public class Application {
    
    private final ConfigService configService;
    
    public Application(ConfigService configService) {
        this.configService = configService;
    }
    
    public void initialize() {
        AppSettings settings = configService.getAppSettings();
        System.out.println("Theme: " + settings.getTheme());
        
        FeatureFlags flags = configService.getFeatureFlags();
        if (flags.isDarkMode()) {
            enableDarkMode();
        }
        
        DatabaseConfig db = configService.getDatabaseConfig();
        initializeDatabase(db);
    }
}
```

## Jackson Annotations

The SDK uses Jackson for deserialization. Use annotations for custom mapping:

### Property Names

```java
public class Config {
    @JsonProperty("api_endpoint")  // Maps from snake_case
    private String apiEndpoint;
    
    @JsonProperty("max-retries")   // Maps from kebab-case
    private int maxRetries;
}
```

### Ignore Unknown Fields

```java
@JsonIgnoreProperties(ignoreUnknown = true)
public class Config {
    private String knownField;
    // Unknown fields in JSON will be ignored
}
```

### Custom Deserialization

```java
public class Config {
    @JsonDeserialize(using = CustomDeserializer.class)
    private CustomType customField;
}
```

### Date/Time Handling

The SDK registers `JavaTimeModule` automatically:

```java
public class Config {
    private Instant createdAt;      // ISO-8601 string → Instant
    private LocalDate expiryDate;   // ISO-8601 date → LocalDate
    private Duration timeout;       // ISO-8601 duration → Duration
}
```

## Validation

Add validation to your model classes:

### Using Jakarta Validation

```java
import jakarta.validation.constraints.*;

public class AppSettings {
    
    @NotBlank
    @Pattern(regexp = "light|dark|system")
    private String theme;
    
    @Min(1)
    @Max(100)
    private int maxItems;
    
    @NotNull
    @Size(min = 1)
    private List<String> features;
}

// Validate after loading
var settings = sdk.getConfigAPI().getAs("MyApp.Settings", AppSettings.class);
validator.validate(settings.getData());
```

### Custom Validation

```java
public class AppSettings {
    private String theme;
    private int maxItems;
    private DatabaseConfig database;
    
    public void validate() {
        if (theme == null || theme.isBlank()) {
            throw new ValidationException("theme is required");
        }
        if (maxItems < 1) {
            throw new ValidationException("maxItems must be positive");
        }
        if (database == null) {
            throw new ValidationException("database configuration is required");
        }
        database.validate();
    }
}
```

## Best Practices

### 1. Use Immutable Models When Possible

```java
// With records (Java 16+)
public record AppSettings(
    String theme,
    int maxItems,
    List<String> features
) {
    public AppSettings {
        features = List.copyOf(features); // Defensive copy
    }
}
```

### 2. Separate Configuration by Domain

```java
// ✅ Domain-specific models
public class AuthConfig { ... }
public class DatabaseConfig { ... }
public class FeatureFlags { ... }

// ❌ One giant config class
public class AllSettings { ... }
```

### 3. Handle Deserialization Errors

```java
try {
    var config = sdk.getConfigAPI().getAs("MyApp.Settings", AppSettings.class);
} catch (ApiError e) {
    // API error
    log.error("API error: {}", e.getMessage());
} catch (Exception e) {
    // Deserialization error
    log.error("Failed to deserialize config", e);
}
```

### 4. Version Your Models

When configs evolve, version your model classes:

```java
// V1
public class AppSettingsV1 {
    private String theme;
}

// V2 - added new fields
public class AppSettingsV2 {
    private String theme;
    private int maxItems;  // New in v2
}
```

## Next Steps

- **[Examples →](examples)** — Real-world usage patterns
